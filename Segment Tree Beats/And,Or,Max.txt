//    #pragma GCC optimize ("O3")
//    #pragma GCC optimize ("unroll-loops")
//    #pragma comment(linker, "/STACK:2000000")
#include<bits/stdc++.h>

using namespace std;
#define ll long long
#define int ll
#define ld long double
#define  ui unsigned int
#define endl "\n"
#define FOCUS ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);

void Go() {
    ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
}

const int N = 2e6;
const int BITS = 22;
const int ALL_BITS = (1 << BITS) - 1;

struct item {
    int mx = 0;
    int Or = 0;
    int And = ALL_BITS;
    int lazyAnd = ALL_BITS;
    int lazyOr = 0;
};

vector<item> tree(N);
// sum max
item merge(item a, item b) {
    item ret;
    ret.mx = max(a.mx, b.mx);
    ret.Or = (a.Or | b.Or);
    ret.And = (a.And & b.And);
    return ret;
}

void apply_update(int pos,int valOr,int valAnd) {
    tree[pos].lazyOr = (tree[pos].lazyOr & valAnd) | valOr; // Must be calculated first!
    tree[pos].lazyAnd &= valAnd;
    // The updates to the actual values are correct
    tree[pos].Or = (tree[pos].Or & valAnd) | valOr;
    tree[pos].And = (tree[pos].And & valAnd) | valOr;
    tree[pos].mx = (tree[pos].mx & valAnd) | valOr;
}

void propagate(int pos,int l,int r) {
    if (tree[pos].lazyOr == 0 && tree[pos].lazyAnd == ALL_BITS || l == r)return;
    int valAnd = tree[pos].lazyAnd;
    int valOr = tree[pos].lazyOr;
    apply_update(pos * 2 + 1, valOr, valAnd);
    apply_update(pos * 2 + 2, valOr, valAnd);
    tree[pos].lazyOr = 0;
    tree[pos].lazyAnd = ALL_BITS;
}

void assign(int pos,int idx,int val,int st,int en) {
    if (idx < st || idx > en)return;
    int mid = st + (en - st) / 2;
    if (st == en) {
        tree[pos] = {val, val, val, ALL_BITS, 0};
        return;
    }
    assign(pos * 2 + 1, idx, val, st, mid);
    assign(pos * 2 + 2, idx, val, mid + 1, en);
    tree[pos] = merge(tree[pos * 2 + 1], tree[pos * 2 + 2]);
}

void OR(int val,int l,int r,int pos,int st,int en) {
    if (l > en || r < st)return;
    propagate(pos, st, en);
    int trueOr = tree[pos].Or;
    int trueAnd = tree[pos].And;
    if (st >= l && en <= r) {
        // Condition: for any bit X wants to turn on, it's not a mixed bit

        if ((val & (trueOr & ~trueAnd)) == 0) {
            apply_update(pos, val, ALL_BITS);
            return;
        }
    }
    int mid = (st + en) / 2;
    OR(val, l, r, pos * 2 + 1, st, mid);
    OR(val, l, r, pos * 2 + 2, mid + 1, en);
    tree[pos] = merge(tree[pos * 2 + 1], tree[pos * 2 + 2]);
}

void AND(int val,int l,int r,int pos,int st,int en) {
    if (l > en || r < st)return;
    propagate(pos, st, en);
    int trueOr = tree[pos].Or;
    int trueAnd = tree[pos].And;
    if (st >= l && en <= r) {
        // Condition: for any bit X wants to turn off, it's not a mixed bit
        if ((~val & (trueOr & ~trueAnd)) == 0) {
            apply_update(pos, 0, val);
            return;
        }
    }
    int mid = (st + en) / 2;
    AND(val, l, r, pos * 2 + 1, st, mid);
    AND(val, l, r, pos * 2 + 2, mid + 1, en);
    tree[pos] = merge(tree[pos * 2 + 1], tree[pos * 2 + 2]);
}

int query(int pos,int l,int r,int st,int en) {
    propagate(pos, st, en);
    if (l > en || r < st)return 0;
    if (st >= l && en <= r) {
        return tree[pos].mx;
    }
    int mid = st + (en - st) / 2;
    return max(query(pos * 2 + 1, l, r, st, mid), query(pos * 2 + 2, l, r, mid + 1, en));
}

signed main() {
    Go();
    int n, q;
    cin >> n >> q;
    vector<int> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        assign(0, i, v[i], 0, n - 1);
    }
    while (q--) {
        int type;
        cin >> type;
        if (type == 1) {
            int l, r, x;
            cin >> l >> r >> x;
            l--, r--;
            AND(x, l, r, 0, 0, n - 1);
        } else if (type == 2) {
            int l, r, x;
            cin >> l >> r >> x;
            l--, r--;
            OR(x, l, r, 0, 0, n - 1);
        } else {
            int l, r;
            cin >> l >> r;
            l--, r--;
            cout << query(0, l, r, 0, n - 1) << endl;;
        }
    }
}
